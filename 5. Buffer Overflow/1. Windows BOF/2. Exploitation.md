# BOF Exploitation


## 1. Replicating the crash

Once the vulnerability is discovered, we need to find the way to control the EIP. In this moment, the objective is to rewrite the fuzzer script that crashes the app with a fixed length (without loop). Let's say 800 bytes.
_____
## 2. Controlling EIP

The crucial step here is to find which part of our buffer (800 bytes) is landing in the EIP register. To do this, there are two common ways to do it:

#### 2.1 Binary Tree Analysis (slowest)

This method requires sending the buffer with half of it being A's and the other half being B's (AAAAA...BBBBB). If the EIP register is overwritten by B's, we know the EIP is inside the second half. We now take this half and split in two parts, left part being B's and the right part being C's. The process continues until we find the exact four bytes that overwrite EIP.

#### 2.2 Patterns (faster)

The point here is to create a long string that consists of non-repeated 4 bytes as the fuzzing data. Once the EIP is overwritten with these 4 bytes, we can identify where exactly happened using various tools.

```bash
#Creating the string with a length of 800 bytes:
msf-pattern_create -l 800
```

At this point, copy the value of the EIP register and execute the following command to extract the exact offset:

```bash
#-l is the length of the original string:
msf-pattern_offset -l 800 -q 42306142
```

Once identified the offset, we can execute a test by using A's for the offset, B's for 4 EIP bytes and C's for the rest. If the EIP is 0x42424242 we are good!

```python
filler = "A" * 780
eip = "B" * 4
buffer = "C" * 16
```
